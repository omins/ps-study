## 1520번 문제

[문제 링크](https://www.acmicpc.net/problem/1520)

### 생각한 것

1. 모든 경로를 봐야하기 때문에 방문처리하고 DFS를 재귀적으로 한 뒤, 다시 방문을 해제해주면 되는 문제로 접근.
2. 시간초과.
3. 찾아보니, 이러한 방식으로는 `board[x][y]`에 대해 중복해서 탐색할 수 있다. 다른 경로로 접근할 때 `board[x][y]`가 완전히 새로운 위치이기 때문에 다시 재귀적으로 탐색하기 때문이다.
4. 따라서 `board[x][y]`에서 `board[n - 1][m - 1]`까지 가는 경로의 수를 한 번 계산했다면, 이를 저장하여 재활용한다.

### 시간 복잡도

$O(NM)$

### 사용한 자료구조 / 알고리즘

DFS, DP

### 코멘트

- **(중요) 일반 DFS와 백트래킹에서는 같은 연산을 중복해서 수행할 수 있다. 따라서 최적화가 필요한데, 동적 계획법 (Dynamic Programming)을 통해 달성할 수 있다.**

### 난이도 / 걸린 시간

- 골드3 / 다른 정답 코드 보고 이해하는 시간까지 1시간 10분
