## 문제풀이
[문제링크](https://www.acmicpc.net/problem/1520)

문제 난이도 : 골드 3

소요시간 : 3시간 30분

### 문제접근
처음에 활용한 방법은 dfs만을 활용해서 답을 구했다.<br/>
예제는 문제없이 통과한것 처럼 보였다.<br/>
하지만 제출을 했을때 통과실패 문제는 시간초과 였다.<br/>
M과 N의 최대값이 500인데 모든 경우의 수를 보면서 탐색을 진행하면 제한시간안에 들어올 수 없었던 것이다.

오랜시간 혼자 고민을 하다가 도저히 해결안이 생각나지 않아서 검색을 해보니 해당 문제는<br/> 
dfs, dp 두가지를 활용하여 문제를 해결해야 하는데 나는 아직 dp를 공부한 적이 없다. 
애초에 방법을 모르면서 문제를 해결하려 한것... 이를 알게되고 내가 필요한 dp를 이해하기 위해서 수기로 적으면서 공부를 진행했다. 그리고 어느정도 이해를 마치고 다시 코드를 적어 보았다.

#### 다시 작성하면서 생각한 것들

dfs로 어떤 값을 리턴할 것인가?

#### 가장 끝에 도달했다면

가장 끝에 도달하면 1을 리턴한다.

이전 노드에서 마지막 노드로 오는 방향은 1개 밖에 없기 때문.

#### 이미 방문한 위치라면 

해당 위치에 저장되어 있는 값을 리턴한다.

#### 어떤 로직으로 ?

1. 출발점에서 dfs를 실행시킨다.
2. 현재 위치가 종점이라면 1을 리턴
3. 현재 위치를 방문한 적이 있다면 해당 위치의 값을 리턴
4. 현재 위치를 통과하는 경로의 수를 기록할 cnt라는 변수를 생성하고 0으로 초기화
5. 방문한 적이 없고 현재 위치보다 낮은 높이를 가지고 있다면
>* 상하좌우 이동가능한 위치를 확인하고 이동가능한 위치마다 dfs를 실행.
>* 리턴된 값을 cnt에 더해준다.
6. 현재 위치의 값을 cnt의 값으로 바꿔준다.
7. cnt를 리턴한다. (해당 값이 5번의 세부 로직에 리턴되는 값)

위 로직으로 실행을 시키게 되면 dp에 각 노드마다 몇개의 경로에 해당 노드가 포함되어 있는지 저장되게 되는데 이때 출발 노드에 저장되어 있는 값을 출력하게 된다면 출발노드가 몇개의 경로에 포함되어 있는지 알 수 있게 된다.

### 풀이코드

#### 함수코드
```js
function dfs(x, y) {
    if (x === M - 1 && y === N - 1) {
        return 1; // 최종지점의 도착하면 1을 리턴해서 거쳐온 경로들을 방문처리
    }

    if (dp[x][y] !== -1) {
        return dp[x][y]; // 이미 방문한 경로라면 현재 경로에 누적된 값을 리턴
    }

    let cnt = 0;

    for (let i = 0; i < 4; i++) {
        const nx = x + dx[i];
        const ny = y + dy[i];

        if (isValidation(nx, ny) && graph[x][y] > graph[nx][ny]) {
            // 분기점에서 cnt 가 누적되고 누적된 카운트가 출발점에 쌓여서 최종으로 이동가능한 경로의 수가 기록된다.
            // 예시 => 1,0 에서 이동 가능한 경로가 [1,1], [2,0] 이라면 1,0 은 2의 값을 가지게 되고 1,0이 거쳐온 모든 경로도 동일한 값이 기록된다.(새로운 분기점을 만나기 전까지의 경로)
            // dp의 각노드에 기록된 수는 해당 노드를 거쳐서 이동할 수 있는 경로의 수.
            cnt += dfs(nx, ny); 
        }
    }
    dp[x][y] = cnt;
    return cnt;
}
```

#### 기본코드
```js
const fs = require("fs");
const filepath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
const input = fs.readFileSync(filepath).toString().trim().split("\n");

const [M, N] = input.shift().split(" ").map(Number);
const graph = input.map(v => v.split(" ").map(Number));
const dp = new Array(M).fill(null).map(() => new Array(N).fill(-1));
const dx = [1, 0, -1, 0];
const dy = [0, 1, 0, -1];

console.log(dfs(0, 0));
```